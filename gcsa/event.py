from tzlocal import get_localzone
from datetime import datetime, date, timedelta

from util.date_time_util import insure_localisation


class Visibility:
    """ Possible values of the event visibility.

    DEFAULT - Uses the default visibility for events on the calendar. This is the default value.
    PUBLIC - The event is public and event details are visible to all readers of the calendar.
    PRIVATE - The event is private and only event attendees may view event details.
    """

    DEFAULT = "default"
    PUBLIC = "public"
    PRIVATE = "private"


class Event:
    def __init__(self,
                 start,
                 end=None,
                 timezone=str(get_localzone()),
                 event_id=None,
                 summary=None,
                 description=None,
                 location=None,
                 recurrence=None,
                 color=None,
                 visibility=Visibility.DEFAULT,
                 gadget=None,
                 attachments=None,
                 reminders=None,
                 default_reminders=True,
                 **other):
        """
        :param start: Starting date/datetime.
        :param end: Ending date/datetime. If 'end' is not specified, event is considered as a 1-day or 1-hour event
                    if 'start' is date or datetime respectively.
        :param timezone: Timezone formatted as an IANA Time Zone Database name, e.g. "Europe/Zurich". By default,
                         the computers configured local timezone(if any) is used.
        :param event_id: Opaque identifier of the event. By default is generated by the server. You can specify id as a
                         5-1024 long string of characters used in base32hex ([a-vA-V0-9]). The ID must be unique per
                         calendar.
        :param summary: Title of the event.
        :param description: Description of the event.
        :param location: Geographic location of the event as free-form text.
        :param recurrence: TODO when ready.
        :param color: color id referring to an entry from colors endpoint (list_event_colors)
        :param visibility: Visibility of the event. Default is default visibility for events on the calendar.
        :param gadget: TODO when ready.
        :param attachments: TODO when ready.
        :param reminders: List of reminders. TODO when ready.
        :param default_reminders: Whether the default reminders of the calendar apply to the event.
        :param other: Other fields that should be included in request json. Will be included as they are.
        """

        self.start = start
        if end:
            self.end = end
        elif isinstance(start, datetime):
            self.end = start + timedelta(hours=1)
        elif isinstance(start, date):
            self.end = start + timedelta(days=1)

        if isinstance(self.start, datetime) and isinstance(self.end, datetime):
            self.start = insure_localisation(self.start, timezone)
            self.end = insure_localisation(self.end, timezone)
        elif not (isinstance(self.start, date) and isinstance(self.end, date)):
            raise TypeError('Start and end must either both be date or both be datetime.')

        self.event_id = event_id.lower()
        self.summary = summary
        self.description = description
        self.location = location
        self.recurrence = recurrence or []
        self.colorId = color
        self.visibility = visibility
        self.gadget = gadget
        self.attachments = attachments or []
        self.reminders = reminders or []
        self.default_reminders = default_reminders
        self.other = other

    def get_id(self):
        return self.event_id

    def add_attachment(self, file_url, title='', mime_type=None, icon_link=None):
        new_attachment = {
            "title": title,
            "fileUrl": file_url,
            "mimeType": mime_type,
            "iconLink": icon_link,
        }
        self.attachments.append(new_attachment)

    def add_email_reminder(self, minutes_before_start=60):
        self.add_reminder('email', minutes_before_start)

    def add_popup_reminder(self, minutes_before_start=30):
        self.add_reminder('popup', minutes_before_start)

    def add_reminder(self, method, minutes_before_start):
        new_reminder = {
            'method': method,
            'minutes': minutes_before_start
        }
        self.reminders.append(new_reminder)

    def __str__(self):
        return f'{self.start} - {self.summary}'
